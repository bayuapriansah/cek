
<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="icon" href="../../../../favicon.ico">
  <title>COLOR HARMONY</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="css/style.css">
  <!-- Custom styles for this template -->
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
      <style>
    #theform table {
    	
    }
    #theform td {
    	
    }
    
    h1, h2, h3 {
    	display:inline;
    	margin:0;
    	padding:0;
    }
    h2 {
    	font-size:14pt;
    }
    
    #header {
    	padding:12px 25px;
    	background-color:#139;
    }
    #header h1, #header h2 {
    	display:inline;
    	color:#fff;
    }
    #cwnav {
    	position:absolute;
    	top:-1px;
    	background-color:#139;
    	width:100%;
    }
    #cwnav>div:last-child { display:none; } 
    
    #navcontainer {
    	position:relative!important;
    	margin:0 auto;
    }
    
    #top {
    	position:relative;
    	text-align:center;
    	padding:8px 0;
    }
    
    #bottom {
    	position:relative;
    	text-align:center;
    	margin-top:15px;
    }
    
    #everything {
    	position:relative;
    }
    
    #cwmain { padding-top:12px; }
    #cwmain form {
    	display:inline;
    }
    
    #monochrome, #analogous, #complementary, #splitcomplementary, #triadic {
    	position:relative;
    	height:255px;
    	text-align:center;
    }
    
    #complementary { width:182px; }
    #splitcomplementary { width:274px; }
    #triadic { width:274px; }
    #analogous { width:274px; }
    
    .swatch {
    	position:absolute;
    	height:42px;
    	width:90px;
    	font-size:7pt;
    	text-align:center;
    	background:black;
    	color:transparent;
    }
    .swatch:hover {
    	color:#666;
    }
    
    .sa { top:30px; }
    .sb { top:74px; }
    .sc { top:118px; }
    .sd { top:162px; }
    .se { top:206px; }
    
    .s1 { left:0px; }
    .s2 { left:92px; }
    .s3 { left:184px; }
    
    #TriggerNoteStripeBottom>div:last-child { padding:0!important; }
    </style>
</head>
<body>
  <div class="jarak">
    <div class="container">
      <div class="header clearfix">
        <h3 class="text-muted">Color Wheel Harmony</h3>
      </div>
      <div class="jumbotron">
        <div class="container">
<table id="cwmain" cellspacing="0">
	</td><td valign="top">
		<table cellspacing="0" style="width:770px;"><tr>
		<td valign="top">
			

		<form action="javascript:DoNothing();" id="theform" method="post">
			<form action="#" id="theform" method="post">
			<table cellspacing="0">
		<tr>
				<td><input type="hidden" id="ri" size="3" value="00" tabindex="1" /></td>
				<td><input type="hidden" id="rih" size="2" value="00" tabindex="4" /></td>
				<td><input type="hidden" id="grade1" size="5" value="0.8" tabindex="8" /></td>
			</tr>
			<tr>
				<td><input type="hidden" id="gi" size="3" value="00" tabindex="2" /></td>
				<td><input type="hidden" id="gih" size="2" value="00" tabindex="5" /></td>
				<td><input type="hidden" id="grade2" size="5" value="0.4" tabindex="9" /></td>
			</tr>
			<tr>
            <td><input type="hidden" id="bi" size="3" value="00" tabindex="3" /></td>
				<td><input type="hidden" id="bih" size="2" value="00" tabindex="6" /></td>
				<td><input type="hidden" id="grade3" size="5" value="0.6" tabindex="10" /></td>
			</tr>
			<tr>
				<td colspan="2"><input type="hidden" id="angle" size="5" value="30.0" tabindex="7" /></td>
				<td><input type="hidden" id="grade4" size="5" value="0.3" tabindex="11" /></td>
			</tr><tr>
				 <div class="colorPicker"></div>
    <!-- <input type="text" id="jscolor" size="7" value="#ff0a12" tabindex="12" class="colour" style="visibility: hidden;"/>  Click here and press enter once you've selected your colour 	</table> -->
    <input type="text" id="jscolor" size="7" value="#ff0a12" tabindex="12" class="colour"/>  <!--Click here and press enter once you've selected your colour --> 	</table>
			</form>
		</td><td valign="top" align="center">
			<div id="complementary">
				<h2>Complementary</h2>
				<div id="cc1a" class="swatch sa s1"></div>
				<div id="cc1b" class="swatch sb s1"></div>
				<div id="cc1c" class="swatch sc s1"></div>
				<div id="cc1d" class="swatch sd s1"></div>
				<div id="cc1e" class="swatch se s1"></div>

				<div id="cc2a" class="swatch sa s2"></div>
				<div id="cc2b" class="swatch sb s2"></div>
				<div id="cc2c" class="swatch sc s2"></div>
				<div id="cc2d" class="swatch sd s2"></div>
				<div id="cc2e" class="swatch se s2"></div>
			</div>
		</td><td valign="top" align="right">
			<div id="splitcomplementary">
				<h2>Split&nbsp;Complementary</h2>
				<div id="sc1a" class="swatch sa s1"></div>
				<div id="sc1b" class="swatch sb s1"></div>
				<div id="sc1c" class="swatch sc s1"></div>
				<div id="sc1d" class="swatch sd s1"></div>
				<div id="sc1e" class="swatch se s1"></div>

				<div id="sc2a" class="swatch sa s2"></div>
				<div id="sc2b" class="swatch sb s2"></div>
				<div id="sc2c" class="swatch sc s2"></div>
				<div id="sc2d" class="swatch sd s2"></div>
				<div id="sc2e" class="swatch se s2"></div>

				<div id="sc3a" class="swatch sa s3"></div>
				<div id="sc3b" class="swatch sb s3"></div>
				<div id="sc3c" class="swatch sc s3"></div>
				<div id="sc3d" class="swatch sd s3"></div>
				<div id="sc3e" class="swatch se s3"></div>
			</div>
		</td>
		</tr></table>
	</td>
</tr><tr>

</tr><tr>
	<td>
		<table cellspacing="0" style="width:770px;"><tr>
		<td style="width:140px;">
			<div id="monochrome">
				<h2>Monochrome</h2>
				<div id="mc1a" class="swatch sa s1"></div>
				<div id="mc1b" class="swatch sb s1"></div>
				<div id="mc1c" class="swatch sc s1"></div>
				<div id="mc1d" class="swatch sd s1"></div>
				<div id="mc1e" class="swatch se s1"></div>
			</div>
		</td><td align="center">
			<div id="triadic">
				<h2>Triadic</h2>
				<div id="tc1a" class="swatch sa s2"></div>
				<div id="tc1b" class="swatch sb s2"></div>
				<div id="tc1c" class="swatch sc s2"></div>
				<div id="tc1d" class="swatch sd s2"></div>
				<div id="tc1e" class="swatch se s2"></div>

				<div id="tc2a" class="swatch sa s1"></div>
				<div id="tc2b" class="swatch sb s1"></div>
				<div id="tc2c" class="swatch sc s1"></div>
				<div id="tc2d" class="swatch sd s1"></div>
				<div id="tc2e" class="swatch se s1"></div>

				<div id="tc3a" class="swatch sa s3"></div>
				<div id="tc3b" class="swatch sb s3"></div>
				<div id="tc3c" class="swatch sc s3"></div>
				<div id="tc3d" class="swatch sd s3"></div>
				<div id="tc3e" class="swatch se s3"></div>
			</div>
		</td><td align="right">
			<div id="analogous">
				<h2>Analogous</h2>
				<div id="ac1a" class="swatch sa s1"></div>
				<div id="ac1b" class="swatch sb s1"></div>
				<div id="ac1c" class="swatch sc s1"></div>
				<div id="ac1d" class="swatch sd s1"></div>
				<div id="ac1e" class="swatch se s1"></div>

				<div id="ac2a" class="swatch sa s2"></div>
				<div id="ac2b" class="swatch sb s2"></div>
				<div id="ac2c" class="swatch sc s2"></div>
				<div id="ac2d" class="swatch sd s2"></div>
				<div id="ac2e" class="swatch se s2"></div>

				<div id="ac3a" class="swatch sa s3"></div>
				<div id="ac3b" class="swatch sb s3"></div>
				<div id="ac3c" class="swatch sc s3"></div>
				<div id="ac3d" class="swatch sd s3"></div>
				<div id="ac3e" class="swatch se s3"></div>
			</div>
		</td>
		</tr></table>
	</td>
</tr>
</table>
<script>
/*!
 * iro.js v3.5.3
 * 2016-2018 James Daniel
 * Released under the MIT License
 * github.com/jaames/iro.js
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.iro = factory());
}(this, (function () { 'use strict';

  // css class prefix for this element
  var CLASS_PREFIX = "iro__marker";
  var marker = function marker(svg, opts) {
    var baseGroup = svg.g({
      class: CLASS_PREFIX
    });
    baseGroup.circle(0, 0, opts.r, {
      class: CLASS_PREFIX + "__outer",
      fill: "none",
      strokeWidth: 5,
      stroke: "#000"
    });
    baseGroup.circle(0, 0, opts.r, {
      class: CLASS_PREFIX + "__inner",
      fill: "none",
      strokeWidth: 2,
      stroke: "#fff"
    });
    this.g = baseGroup;
  };
  /**
    * @desc move marker to centerpoint (x, y) and redraw
    * @param {Number} x - point x coordinate
    * @param {Number} y - point y coordinate
  */


  marker.prototype.move = function move (x, y) {
    this.g.setTransform("translate", [x, y]);
  };

  var CLASS_PREFIX$1 = "iro__wheel"; // Quick references to reused math functions

  var PI = Math.PI,
      sqrt = Math.sqrt,
      abs = Math.abs,
      round = Math.round;
  var wheel = function wheel(svg, opts) {
    this._opts = opts;
    this.type = "wheel";
    var cY = opts.cY,
        cX = opts.cX,
        r = opts.r,
        border = opts.border;
    var baseGroup = svg.g({
      class: CLASS_PREFIX$1
    });
    baseGroup.circle(cX, cY, r + border.w / 2, {
      class: CLASS_PREFIX$1 + "__border",
      fill: "#fff",
      stroke: border.color,
      strokeWidth: border.w
    });
    var ringGroup = baseGroup.g({
      class: CLASS_PREFIX$1 + "__hue",
      strokeWidth: r,
      fill: "none"
    });

    for (var hue = 0; hue < 360; hue++) {
      ringGroup.arc(cX, cY, r / 2, hue, hue + 1.5, {
        stroke: "hsl(" + (opts.anticlockwise ? 360 - hue : hue) + ",100%,50%)"
      });
    }

    var saturation = baseGroup.circle(cX, cY, r, {
      class: CLASS_PREFIX$1 + "__saturation"
    });
    saturation.setGradient("fill", svg.gradient("radial", {
      0: {
        color: "#fff"
      },
      100: {
        color: "#fff",
        opacity: 0
      }
    }));
    this._lightness = baseGroup.circle(cX, cY, r, {
      class: CLASS_PREFIX$1 + "__lightness",
      opacity: 0
    });
    this.marker = new marker(baseGroup, opts.marker);
  };
  /**
    * @desc updates this element to represent a new color value
    * @param {Object} color - an iroColor object with the new color value
    * @param {Object} changes - an object that gives a boolean for each HSV channel, indicating whether ot not that channel has changed
  */


  wheel.prototype.update = function update (color, changes) {
    var opts = this._opts;
    var hsv = color.hsv; // If the V channel has changed, redraw the wheel UI with the new value

    if (changes.v && opts.lightness) {
      this._lightness.setAttrs({
        opacity: (1 - hsv.v / 100).toFixed(2)
      });
    } // If the H or S channel has changed, move the marker to the right position


    if (changes.h || changes.s) {
      // convert the hue value to radians, since we'll use it as an angle
      var hueAngle = (opts.anticlockwise ? 360 - hsv.h : hsv.h) * (PI / 180); // convert the saturation value to a distance between the center of the ring and the edge

      var dist = hsv.s / 100 * opts.rMax; // Move the marker based on the angle and distance

      this.marker.move(opts.cX + dist * Math.cos(hueAngle), opts.cY + dist * Math.sin(hueAngle));
    }
  };
  /**
    * @desc Takes a point at (x, y) and returns HSV values based on this input -- use this to update a color from mouse input
    * @param {Number} x - point x coordinate
    * @param {Number} y - point y coordinate
    * @return {Object} - new HSV color values (some channels may be missing)
  */


  wheel.prototype.input = function input (x, y) {
    var opts = this._opts,
        rangeMax = opts.rMax,
        _x = opts.cX - x,
        _y = opts.cY - y;

    var angle = Math.atan2(_y, _x),
        // Calculate the hue by converting the angle to radians
    hue = round(angle * (180 / PI)) + 180,
        // Find the point's distance from the center of the wheel
    // This is used to show the saturation level
    dist = Math.min(sqrt(_x * _x + _y * _y), rangeMax);
    hue = opts.anticlockwise ? 360 - hue : hue; // Return just the H and S channels, the wheel element doesn't do anything with the L channel

    return {
      h: hue,
      s: round(100 / rangeMax * dist)
    };
  };
  /**
    * @desc Check if a point at (x, y) is inside this element
    * @param {Number} x - point x coordinate
    * @param {Number} y - point y coordinate
    * @return {Boolean} - true if the point is a "hit", else false
  */


  wheel.prototype.checkHit = function checkHit (x, y) {
    var opts = this._opts; // Check if the point is within the hue ring by comparing the point's distance from the centre to the ring's radius
    // If the distance is smaller than the radius, then we have a hit

    var dx = abs(x - opts.cX),
        dy = abs(y - opts.cY);
    return sqrt(dx * dx + dy * dy) < opts.r;
  };

  var round$1 = Math.round;
  var floor = Math.floor;
  /**
    * @desc generic parser for hsl / rgb / etc string
    * @param {String} str - color string
    * @param {Array} maxValues - max values for each channel (used for calculating percent-based values)
    * @return {Array} type (rgb | rgba | hsl | hsla) values for each channel
  */

  function parseColorStr(str, maxValues) {
    var parsed = str.match(/(\S+)\((\d+)(%?)(?:\D+?)(\d+)(%?)(?:\D+?)(\d+)(%?)(?:\D+?)?([0-9\.]+?)?\)/i),
        val1 = parseInt(parsed[2]),
        val2 = parseInt(parsed[4]),
        val3 = parseInt(parsed[6]);
    return [parsed[1], parsed[3] == "%" ? val1 / 100 * maxValues[0] : val1, parsed[5] == "%" ? val2 / 100 * maxValues[1] : val2, parsed[7] == "%" ? val3 / 100 * maxValues[2] : val3, parseFloat(parsed[8]) || undefined];
  }
  /**
    * @desc convert object / string input to color if necessary
    * @param {Object | String | color} value - color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)
    * @return {color} color instance
  */

  function getColor(value) {
    return value instanceof color ? value : new color(value);
  }
  /**
    * @desc clamp value between min and max
    * @param {Number} value
    * @param {Number} min
    * @param {Number} max
    * @return {Number}
  */

  function clamp(value, min, max) {
    return value <= min ? min : value >= max ? max : value;
  }
  /**
    * @desc compare values between two objects, returns a object representing changes with true/false values
    * @param {Object} a
    * @param {Object} b
    * @return {Object}
  */

  function compareObjs(a, b) {
    var changes = {};

    for (var key in a) { changes[key] = b[key] != a[key]; }

    return changes;
  }
  var color = function color(value) {
    // The watch callback function for this color will be stored here
    this._onChange = false; // The default color value

    this._value = {
      h: undefined,
      s: undefined,
      v: undefined
    };
    if (value) { this.set(value); }
  };

  var prototypeAccessors = { hsv: { configurable: true },rgb: { configurable: true },hsl: { configurable: true },rgbString: { configurable: true },hexString: { configurable: true },hslString: { configurable: true } };
  /**
    * @desc mix two colors
    * @param {Object | String | color} color1 - color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)
    * @param {Object | String | color} color2 - color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)
    * @param {Number} weight - closer to 0 = more color1, closer to 100 = more color2
    * @return {color} color instance
  */


  color.mix = function mix (color1, color2, weight) {
    var rgb1 = getColor(color1).rgb,
        rgb2 = getColor(color2).rgb;
    weight = clamp(weight / 100 || 0.5, 0, 1);
    return new color({
      r: floor(rgb1.r + (rgb2.r - rgb1.r) * weight),
      g: floor(rgb1.g + (rgb2.g - rgb1.g) * weight),
      b: floor(rgb1.b + (rgb2.b - rgb1.b) * weight)
    });
  };
  /**
    * @desc lighten color by amount
    * @param {Object | String | color} color - color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)
    * @param {Number} amount
    * @return {color} color instance
  */


  color.lighten = function lighten (color, amount) {
    var col = getColor(color),
        hsv = col.hsv;
    hsv.v = clamp(hsv.v + amount, 0, 100);
    col.hsv = hsv;
    return col;
  };
  /**
    * @desc darken color by amount
    * @param {Object | String | color} color - color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)
    * @param {Number} amount
    * @return {color} color instance
  */


  color.darken = function darken (color, amount) {
    var col = getColor(color),
        hsv = col.hsv;
    hsv.v = clamp(hsv.v - amount, 0, 100);
    col.hsv = hsv;
    return col;
  };
  /**
    * @desc convert hsv object to rgb
    * @param {Object} hsv - hsv object
    * @return {Object} rgb object
  */


  color.hsv2Rgb = function hsv2Rgb (hsv) {
    var r, g, b, i, f, p, q, t;
    var h = hsv.h / 360,
        s = hsv.s / 100,
        v = hsv.v / 100;
    i = floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v, g = t, b = p;
        break;

      case 1:
        r = q, g = v, b = p;
        break;

      case 2:
        r = p, g = v, b = t;
        break;

      case 3:
        r = p, g = q, b = v;
        break;

      case 4:
        r = t, g = p, b = v;
        break;

      case 5:
        r = v, g = p, b = q;
        break;
    }

    return {
      r: round$1(r * 255),
      g: round$1(g * 255),
      b: round$1(b * 255)
    };
  };
  /**
    * @desc convert rgb object to hsv
    * @param {Object} rgb - rgb object
    * @return {Object} hsv object
  */


  color.rgb2Hsv = function rgb2Hsv (rgb) {
    // Modified from https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L446
    var r = rgb.r / 255,
        g = rgb.g / 255,
        b = rgb.b / 255,
        max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        delta = max - min,
        hue;

    switch (max) {
      case min:
        hue = 0;
        break;

      case r:
        hue = (g - b) / delta + (g < b ? 6 : 0);
        break;

      case g:
        hue = (b - r) / delta + 2;
        break;

      case b:
        hue = (r - g) / delta + 4;
        break;
    }

    hue /= 6;
    return {
      h: hue * 360,
      s: max == 0 ? 0 : delta / max * 100,
      v: max * 100
    };
  };
  /**
    * @desc convert hsv object to hsl
    * @param {Object} hsv - hsv object
    * @return {Object} hsl object
  */


  color.hsv2Hsl = function hsv2Hsl (hsv) {
    var s = hsv.s / 100,
        v = hsv.v / 100;
    var l = 0.5 * v * (2 - s);
    s = v * s / (1 - Math.abs(2 * l - 1));
    return {
      h: hsv.h,
      s: s * 100 || 0,
      l: l * 100
    };
  };
  /**
    * @desc convert hsl object to hsv
    * @param {Object} hsl - hsl object
    * @return {Object} hsv object
  */


  color.hsl2Hsv = function hsl2Hsv (hsl) {
    var s = hsl.s / 100,
        l = hsl.l / 100;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    return {
      h: hsl.h,
      s: 2 * s / (l + s) * 100,
      v: (l + s) / 2 * 100
    };
  };
  /**
    * @desc convert hsl object to string
    * @param {Object} hsl - hsl object
    * @return {Object} hsl string
  */


  color.hsl2Str = function hsl2Str (hsl) {
    return "hsl" + (hsl.a ? "a" : "") + "(" + hsl.h + ", " + hsl.s + "%, " + hsl.l + "%" + (hsl.a ? ", " + hsl.a : "") + ")";
  };
  /**
    * @desc convert rgb object to string
    * @param {Object} rgb - rgb object
    * @return {Object} rgb string
  */


  color.rgb2Str = function rgb2Str (rgb) {
    return "rgb" + (rgb.a ? "a" : "") + "(" + rgb.r + ", " + rgb.g + ", " + rgb.b + (rgb.a ? ", " + rgb.a : "") + ")";
  };
  /**
    * @desc convert rgb object to hex string
    * @param {Object} rgb - rgb object
    * @return {Object} hex string
  */


  color.rgb2Hex = function rgb2Hex (rgb) {
    var str = "#";
    str += rgb.r.toString(16).padStart(2, "0");
    str += rgb.g.toString(16).padStart(2, "0");
    str += rgb.b.toString(16).padStart(2, "0");
    return str;
  };
  /**
    * @desc parse hex string
    * @param {String} str - color string
    * @return {Object} rgb object
  */


  color.parseHexStr = function parseHexStr (hex) {
    // Strip any "#" characters
    hex = hex.replace("#", ""); // Prefix the hex string with "0x" which indicates a number in hex notation, then convert to an integer

    var int = parseInt("0x" + hex),
        // If the length of the input is only 3, then it is a shorthand hex color
    isShorthand = hex.length == 3,
        // bitMask for isolating each channel
    bitMask = isShorthand ? 0xF : 0xFF,
        // bitLength of each channel (for example, F is 4 bits long while FF is 8 bits long)
    bitLength = isShorthand ? 4 : 8,
        // If we're using shorthand notation, multiply each channel by 17
    multiplier = isShorthand ? 17 : 1;
    return {
      r: (int >> bitLength * 2 & bitMask) * multiplier,
      g: (int >> bitLength & bitMask) * multiplier,
      b: (int & bitMask) * multiplier
    };
  };
  /**
    * @desc parse hsl string
    * @param {String} str - color string
    * @return {Object} hsl object
  */


  color.parseHslStr = function parseHslStr (str) {
    var parsed = parseColorStr(str, [360, 100, 100]);
    return {
      h: parsed[2],
      s: parsed[3],
      l: parsed[4]
    };
  };
  /**
    * @desc parse rgb string
    * @param {String} str - color string
    * @return {Object} rgb object
  */


  color.parseRgbStr = function parseRgbStr (str) {
    var parsed = parseColorStr(str, [255, 255, 255]);
    return {
      r: parsed[1],
      g: parsed[2],
      b: parsed[3]
    };
  };

  prototypeAccessors.hsv.get = function () {
    // _value is cloned to allow changes to be made to the values before passing them back
    var v = this._value;
    return {
      h: v.h,
      s: v.s,
      v: v.v
    };
  };

  prototypeAccessors.hsv.set = function (newValue) {
    // If this color is being watched for changes we need to compare the new and old values to check the difference
    // Otherwise we can just be lazy
    if (this._onChange) {
      var oldValue = this._value;

      for (var channel in oldValue) {
        if (!newValue.hasOwnProperty(channel)) { newValue[channel] = oldValue[channel]; }
      }

      var changes = compareObjs(oldValue, newValue); // Update the old value

      this._value = newValue; // If the value has changed, call hook callback

      if (changes.h || changes.s || changes.v) { this._onChange(this, changes); }
    } else {
      this._value = newValue;
    }
  };

  prototypeAccessors.rgb.get = function () {
    var rgb = color.hsv2Rgb(this._value);
    return {
      r: round$1(rgb.r),
      g: round$1(rgb.g),
      b: round$1(rgb.b)
    };
  };

  prototypeAccessors.rgb.set = function (value) {
    this.hsv = color.rgb2Hsv(value);
  };

  prototypeAccessors.hsl.get = function () {
    var hsl = color.hsv2Hsl(this._value);
    return {
      h: round$1(hsl.h),
      s: round$1(hsl.s),
      l: round$1(hsl.l)
    };
  };

  prototypeAccessors.hsl.set = function (value) {
    this.hsv = color.hsl2Hsv(value);
  };

  prototypeAccessors.rgbString.get = function () {
    return color.rgb2Str(this.rgb);
  };

  prototypeAccessors.rgbString.set = function (value) {
    this.rgb = color.parseRgbStr(value);
  };

  prototypeAccessors.hexString.get = function () {
    return color.rgb2Hex(this.rgb);
  };

  prototypeAccessors.hexString.set = function (value) {
    this.rgb = color.parseHexStr(value);
  };

  prototypeAccessors.hslString.get = function () {
    return color.hsl2Str(this.hsl);
  };

  prototypeAccessors.hslString.set = function (value) {
    this.hsl = color.parseHslStr(value);
  };
  /**
    * @desc set the color from any valid value
    * @param {Object | String | color} value - color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)
  */


  color.prototype.set = function set (value) {
    if (typeof value == "object") {
      if (value instanceof color) {
        this.hsv = color.hsv;
      } else if ("r" in value) {
        this.rgb = value;
      } else if ("v" in value) {
        this.hsv = value;
      } else if ("l" in value) {
        this.hsl = value;
      }
    } else if (typeof value == "string") {
      if (/^rgb/.test(value)) {
        this.rgbString = value;
      } else if (/^hsl/.test(value)) {
        this.hslString = value;
      } else if (/^#[0-9A-Fa-f]/.test(value)) {
        this.hexString = value;
      }
    }
  };
  /**
    * @desc shortcut to set a specific channel value
    * @param {String} model - hsv | hsl | rgb
    * @param {String} channel - individual channel to set, for example if model = hsl, chanel = h | s | l
    * @param {Number} value - new value for the channel
  */


  color.prototype.setChannel = function setChannel (model, channel, value) {
    var v = this[model];
    v[channel] = value;
    this[model] = v;
  };
  /**
    * @desc make new color instance with the same value as this one
    * @return {color}
  */


  color.prototype.clone = function clone () {
    return new color(this);
  };
  /**
    * @desc compare this color against another, returns a object representing changes with true/false values
    * @param {Object | String | color} color - color to compare against
    * @param {String} model - hsv | hsl | rgb
    * @return {Object}
  */


  color.prototype.compare = function compare (color, model) {
    model = model || "hsv";
    return compareObjs(this[model], getColor(color)[model]);
  };
  /**
    * @desc mix a color into this one
    * @param {Object | String | color} color - color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)
    * @param {Number} weight - closer to 0 = more current color, closer to 100 = more new color
  */


  color.prototype.mix = function mix$1 (color, weight) {
    this.hsv = mix(this, color, weight).hsv;
  };
  /**
    * @desc lighten color by amount
    * @param {Number} amount
  */


  color.prototype.lighten = function lighten$1 (amount) {
    lighten(this, amount);
  };
  /**
    * @desc darken color by amount
    * @param {Number} amount
  */


  color.prototype.darken = function darken$1 (amount) {
    darken(this, amount);
  };

  Object.defineProperties( color.prototype, prototypeAccessors );

  var CLASS_PREFIX$2 = "iro__slider";
  var slider = function slider(svg, opts) {
    var r = opts.r,
        w = opts.w,
        h = opts.h,
        x = opts.x,
        y = opts.y,
        borderWidth = opts.border.w; // "range" limits how far the slider's marker can travel, and where it stops and starts along the X axis

    opts.range = {
      min: x + r,
      max: x + w - r,
      w: w - r * 2
    };
    opts.sliderType = opts.sliderType || "v";
    this.type = "slider";
    this._opts = opts;
    var radius = r + borderWidth / 2;
    var baseGroup = svg.g({
      class: CLASS_PREFIX$2
    });
    var rect = baseGroup.insert("rect", {
      class: CLASS_PREFIX$2 + "__value",
      rx: radius,
      ry: radius,
      x: x - borderWidth / 2,
      y: y - borderWidth / 2,
      width: w + borderWidth,
      height: h + borderWidth,
      strokeWidth: borderWidth,
      stroke: opts.border.color
    });
    rect.setGradient("fill", svg.gradient("linear", {
      0: {
        color: "#000"
      },
      100: {
        color: "#fff"
      }
    }));
    this._gradient = rect.gradient;
    this.marker = new marker(baseGroup, opts.marker);
  };
  /**
    * @desc updates this element to represent a new color value
    * @param {Object} color - an iroColor object with the new color value
    * @param {Object} changes - an object that gives a boolean for each HSV channel, indicating whether ot not that channel has changed
  */


  slider.prototype.update = function update (color$$1, changes) {
    var opts = this._opts;
    var range = opts.range;
    var hsv = color$$1.hsv;
    var hsl = color.hsv2Hsl({
      h: hsv.h,
      s: hsv.s,
      v: 100
    });

    if (opts.sliderType == "v") {
      if (changes.h || changes.s) {
        this._gradient.stops[1].setAttrs({
          stopColor: "hsl(" + hsl.h + "," + hsl.s + "%," + hsl.l + "%)"
        });
      }

      if (changes.v) {
        var percent = hsv.v / 100;
        this.marker.move(range.min + percent * range.w, opts.y + opts.h / 2);
      }
    }
  };
  /**
    * @desc Takes a point at (x, y) and returns HSV values based on this input -- use this to update a color from mouse input
    * @param {Number} x - point x coordinate
    * @param {Number} y - point y coordinate
    * @return {Object} - new HSV color values (some channels may be missing)
  */


  slider.prototype.input = function input (x, y) {
    var opts = this._opts;
    var range = opts.range;
    var dist = Math.max(Math.min(x, range.max), range.min) - range.min;
    return {
      v: Math.round(100 / range.w * dist)
    };
  };
  /**
    * @desc Check if a point at (x, y) is inside this element
    * @param {Number} x - point x coordinate
    * @param {Number} y - point y coordinate
    * @return {Boolean} - true if the point is a "hit", else false
  */


  slider.prototype.checkHit = function checkHit (x, y) {
    var opts = this._opts;
    return x > opts.x && x < opts.x + opts.w && y > opts.y && y < opts.y + opts.h;
  };

  var GRADIENT_INDEX = 0;
  var GRADIENT_SUFFIX = "Gradient";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var SVG_ATTRIBUTE_SHORTHANDS = {
    class: "class",
    stroke: "stroke",
    strokeWidth: "stroke-width",
    fill: "fill",
    opacity: "opacity",
    offset: "offset",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity"
  }; // TODO: figure out why these aren't being compressed properly?

  var SVG_TRANSFORM_SHORTHANDS = {
    translate: "setTranslate",
    scale: "setScale",
    rotate: "setRotate"
  }; // sniff useragent string to check if the user is running IE, Edge or Safari

  var ua = window.navigator.userAgent.toLowerCase();
  var IS_IE = /msie|trident|edge/.test(ua);
  var IS_SAFARI = /^((?!chrome|android).)*safari/i.test(ua);

  var svgElement = function svgElement(root, parent, type, attrs) {
    var el = document.createElementNS(SVG_NAMESPACE, type);
    this.el = el;
    this.setAttrs(attrs);
    (parent.el || parent).appendChild(el);
    this._root = root;
    this._svgTransforms = {};
    this._transformList = el.transform ? el.transform.baseVal : false;
  };
  /**
    * @desc insert a new svgElement
    * @param {String} type - element tag name
    * @param {Object} attrs - element attributes
  */


  svgElement.prototype.insert = function insert (type, attrs) {
    return new svgElement(this._root, this, type, attrs);
  };
  /**
    * @desc shorthand to insert a new group svgElement
    * @param {Object} attrs - element attributes
  */


  svgElement.prototype.g = function g (attrs) {
    return this.insert("g", attrs);
  };
  /**
    * @desc shorthand to insert a new arc svgElement
    * @param {Number} cx - arc center x
    * @param {Number} cy - arc center y
    * @param {Number} radius - arc radius
    * @param {Number} startAngle - arc start angle (in degrees)
    * @param {Number} endAngle - arc end angle (in degrees)
    * @param {Object} attrs - element attributes
  */


  svgElement.prototype.arc = function arc (cx, cy, radius, startAngle, endAngle, attrs) {
    var largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;
    startAngle *= Math.PI / 180;
    endAngle *= Math.PI / 180;
    var x1 = cx + radius * Math.cos(endAngle),
        y1 = cy + radius * Math.sin(endAngle),
        x2 = cx + radius * Math.cos(startAngle),
        y2 = cy + radius * Math.sin(startAngle);
    attrs = attrs || {};
    attrs.d = ["M", x1, y1, "A", radius, radius, 0, largeArcFlag, 0, x2, y2].join(" ");
    return this.insert("path", attrs);
  };
  /**
    * @desc shorthand to insert a new circle svgElement
    * @param {Number} cx - circle center x
    * @param {Number} cy - circle center y
    * @param {Number} radius - circle radius
    * @param {Object} attrs - element attributes
  */


  svgElement.prototype.circle = function circle (cx, cy, radius, attrs) {
    attrs = attrs || {};
    attrs.cx = cx;
    attrs.cy = cy;
    attrs.r = radius;
    return this.insert("circle", attrs);
  };
  /**
    * @desc set a rotate/translate/scale transform on this element
    * @param {String} type - transform (rotate | translate | scale)
    * @param {Array} args - transform values
  */


  svgElement.prototype.setTransform = function setTransform (type, args) {
    if (!IS_IE) {
      var transform, transformFn;
      var svgTransforms = this._svgTransforms;

      if (!svgTransforms[type]) {
        transform = this._root.el.createSVGTransform();
        svgTransforms[type] = transform;

        this._transformList.appendItem(transform);
      } else {
        transform = svgTransforms[type];
      }

      transformFn = type in SVG_TRANSFORM_SHORTHANDS ? SVG_TRANSFORM_SHORTHANDS[type] : type;
      transform[transformFn].apply(transform, args);
    } else {
      // Microsoft still can't make a web browser that actually works, as such, Edge + IE dont implement SVG transforms properly.
      // We have to force them instead... geez
      this.setAttrs({
        "transform": type + "(" + args.join(", ") + ")"
      });
    }
  };
  /**
    * @desc set attributes on this element
    * @param {Object} attrs - element attributes
  */


  svgElement.prototype.setAttrs = function setAttrs (attrs) {
      var this$1 = this;

    for (var attr in attrs) {
      var name = attr in SVG_ATTRIBUTE_SHORTHANDS ? SVG_ATTRIBUTE_SHORTHANDS[attr] : attr;
      this$1.el.setAttribute(name, attrs[attr]);
    }
  };

  svgElement.prototype.setGradient = function setGradient (attr, gradient) {
    var attrs = {};
    attrs[attr] = gradient.getUrl();
    gradient._refs[attr] = this;
    this.gradient = gradient;
    this.setAttrs(attrs);
  };

  var svgGradient = function svgGradient(root, type, stops) {
    var stopElements = [];

    var gradient = root._defs.insert(type + GRADIENT_SUFFIX, {
      id: "iro" + GRADIENT_SUFFIX + GRADIENT_INDEX++
    });

    for (var offset in stops) {
      var stop = stops[offset];
      stopElements.push(gradient.insert("stop", {
        offset: offset + "%",
        stopColor: stop.color,
        stopOpacity: stop.opacity === undefined ? 1 : stop.opacity
      }));
    }

    this.el = gradient.el;
    this.stops = stopElements;
    this._refs = {};
  };

  svgGradient.prototype.getUrl = function getUrl (base) {
    var root = IS_SAFARI ? base || location.protocol + "//" + location.host + location.pathname : "";
    return "url(" + root + "#" + this.el.id + ")";
  };

  var svgRoot = (function (svgElement) {
    function svgRoot(parent, width, height, display) {
      svgElement.call(this, null, parent, "svg", {
        width: width,
        height: height,
        style: "display:" + (display || "block") + ";touch-action:none"
      });
      this._root = this;
      this._defs = this.insert("defs");
      this._gradients = [];
    }

    if ( svgElement ) svgRoot.__proto__ = svgElement;
    svgRoot.prototype = Object.create( svgElement && svgElement.prototype );
    svgRoot.prototype.constructor = svgRoot;

    svgRoot.prototype.gradient = function gradient (type, stops) {
      var gradient = new svgGradient(this, type, stops);

      this._gradients.push(gradient);

      return gradient;
    };

    svgRoot.prototype.updateUrls = function updateUrls (base) {
      if (IS_SAFARI) {
        var gradients = this._gradients;

        for (var i = 0; i < gradients.length; i++) {
          for (var key in gradients[i]._refs) {
            var attrs = {};
            attrs[key] = gradients[i].getUrl(base);

            gradients[i]._refs[key].setAttrs(attrs);
          }
        }
      }
    };

    return svgRoot;
  }(svgElement));

  var stylesheet = function stylesheet() {
    // Create a new style element
    var style = document.createElement("style");
    document.head.appendChild(style); // Webkit apparently requires a text node to be inserted into the style element
    // (according to https://davidwalsh.name/add-rules-stylesheets)

    style.appendChild(document.createTextNode(""));
    this.style = style; // Create a reference to the style element's CSSStyleSheet object
    // CSSStyleSheet API: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet

    var sheet = style.sheet;
    this.sheet = sheet; // Get a reference to the sheet's CSSRuleList object
    // CSSRuleList API: https://developer.mozilla.org/en-US/docs/Web/API/CSSRuleList

    this.rules = sheet.rules || sheet.cssRules; // We'll store references to all the CSSStyleDeclaration objects that we change here, keyed by the CSS selector they belong to
    // CSSStyleDeclaration API: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration

    this.map = {};
  };

  var prototypeAccessors$1 = { enabled: { configurable: true },cssText: { configurable: true },css: { configurable: true } };

  prototypeAccessors$1.enabled.get = function () {
    return !this.sheet.disabled;
  };

  prototypeAccessors$1.enabled.set = function (value) {
    this.sheet.disabled = !value;
  }; // TODO: consider removing cssText + css properties since i don't tink they're that useful


  prototypeAccessors$1.cssText.get = function () {
    var map = this.map;
    var ret = [];

    for (var selector in map) {
      ret.push(selector.replace(/,\W/g, ",\n") + " {\n\t" + map[selector].cssText.replace(/;\W/g, ";\n\t") + "\n}");
    }

    return ret.join("\n");
  };

  prototypeAccessors$1.css.get = function () {
    var map = this.map;
    var ret = {};

    for (var selector in map) {
      var ruleSet = map[selector];
      ret[selector] = {};

      for (var i = 0; i < ruleSet.length; i++) {
        var property = ruleSet[i];
        ret[selector][property] = ruleSet.getPropertyValue(property);
      }
    }

    return ret;
  };
  /**
    * @desc Set a specific rule for a given selector
    * @param {String} selector - the CSS selector for this rule (e.g. "body", ".class", "#id")
    * @param {String} property - the CSS property to set (e.g. "background-color", "font-family", "z-index")
    * @param {String} value  - the new value for the rule (e.g. "rgb(255, 255, 255)", "Helvetica", "99")
  */


  stylesheet.prototype.setRule = function setRule (selector, property, value) {
    var sheet = this.sheet;
    var rules = sheet.rules || sheet.cssRules;
    var map = this.map; // Convert property from camelCase to snake-case

    property = property.replace(/([A-Z])/g, function ($1) {
      return "-" + $1.toLowerCase();
    });

    if (!map.hasOwnProperty(selector)) {
      // If the selector hasn't been used yet we want to insert the rule at the end of the CSSRuleList, so we use its length as the index value
      var index = rules.length; // Prepare the rule declaration text, since both insertRule and addRule take this format

      var declaration = property + ": " + value; // Insert the new rule into the stylesheet

      try {
        // Some browsers only support insertRule, others only support addRule, so we have to use both
        sheet.insertRule(selector + " {" + declaration + ";}", index);
      } catch (e) {
        sheet.addRule(selector, declaration, index);
      } finally {
        // Because safari is perhaps the worst browser in all of history, we have to remind it to keep the sheet rules up-to-date
        rules = sheet.rules || sheet.cssRules; // Add our newly inserted rule's CSSStyleDeclaration object to the internal map

        map[selector] = rules[index].style;
      }
    } else {
      map[selector].setProperty(property, value);
    }
  };

  Object.defineProperties( stylesheet.prototype, prototypeAccessors$1 );

  var EVENT_MOUSEDOWN = "mousedown",
        EVENT_MOUSEMOVE = "mousemove",
        EVENT_MOUSEUP = "mouseup",
        EVENT_TOUCHSTART = "touchstart",
        EVENT_TOUCHMOVE = "touchmove",
        EVENT_TOUCHEND = "touchend",
        EVENT_READYSTATE_CHANGE = "readystatechange",
        READYSTATE_COMPLETE = "complete";
  /**
    * @desc listen to one or more events on an element
    * @param {Element} el target element
    * @param {Array} eventList the events to listen to
    * @param {Function} callback the event callback function
    * @param {Object} params params to pass to addEventListener
  */

  function listen(el, eventList, callback, params) {
    if ( params === void 0 ) params = {};

    for (var i = 0; i < eventList.length; i++) {
      el.addEventListener(eventList[i], callback, params);
    }
  }
  /**
    * @desc remove an event listener on an element
    * @param {Element} el target element
    * @param {Array} eventList the events to remove
    * @param {Function} callback the event callback function
  */

  function unlisten(el, eventList, callback) {
    for (var i = 0; i < eventList.length; i++) {
      el.removeEventListener(eventList[i], callback);
    }
  }
  /**
    * @desc call fn callback when the page document is ready
    * @param {Function} callback callback function to be called
  */

  function whenReady(callback) {
    if (document.readyState == READYSTATE_COMPLETE) {
      callback();
    } else {
      listen(document, [EVENT_READYSTATE_CHANGE], function stateChange(e) {
        if (document.readyState == READYSTATE_COMPLETE) {
          callback();
          unlisten(document, [EVENT_READYSTATE_CHANGE], stateChange);
        }
      });
    }
  }
  var colorPicker = function colorPicker(el, opts) {
    var this$1 = this;

    opts = opts || {}; // event storage for `on` and `off`

    this._events = {};
    this._mouseTarget = false;
    this._colorChangeActive = false;
    this.css = opts.css || opts.styles || undefined; // Wait for the document to be ready, then mount the UI

    whenReady(function () {
      this$1._mount(el, opts);
    });
  };
  /**
    * @desc mount the color picker UI into the DOM
    * @param {Element | String} el - a DOM element or the CSS selector for a DOM element to use as a container for the UI
    * @param {Object} opts - options for this instance
    * @access protected
  */


  colorPicker.prototype._mount = function _mount (el, opts) {
      var this$1 = this;

    // If `el` is a string, use it to select an Element, else assume it's an element
    el = "string" == typeof el ? document.querySelector(el) : el; // Find the width and height for the UI
    // If not defined in the options, try the HTML width + height attributes of the wrapper, else default to 320

    var elWidth = parseInt(getComputedStyle(el).width);
    var elHeight = parseInt(getComputedStyle(el).height); //choose the smallest side of the container

    if (elHeight < elWidth && elHeight != 0) {
      elWidth = elHeight;
    } else if (elWidth != 0) {
      elHeight = elWidth;
    }

    var width = opts.width || elWidth || 320;
    var height = opts.height || elHeight || 320; // Calculate layout variables

    var padding = opts.padding + 2 || 6,
        borderWidth = opts.borderWidth || 0,
        markerRadius = opts.markerRadius || 8,
        sliderMargin = opts.sliderMargin || 24,
        sliderHeight = opts.sliderHeight || markerRadius * 2 + padding * 2 + borderWidth * 2,
        bodyWidth = Math.min(height - sliderHeight - sliderMargin, width),
        wheelRadius = bodyWidth / 2 - borderWidth,
        leftMargin = (width - bodyWidth) / 2;
    var marker = {
      r: markerRadius
    };
    var borderStyles = {
      w: borderWidth,
      color: opts.borderColor || "#fff"
    }; // Create UI elements

    this.el = el;
    this.svg = new svgRoot(el, width, height, opts.display);
    this.ui = [new wheel(this.svg, {
      cX: leftMargin + bodyWidth / 2,
      cY: bodyWidth / 2,
      r: wheelRadius,
      rMax: wheelRadius - (markerRadius + padding),
      marker: marker,
      border: borderStyles,
      lightness: opts.wheelLightness == undefined ? true : opts.wheelLightness,
      anticlockwise: opts.anticlockwise
    })/*, new slider(this.svg, {
      sliderType: "v",
      x: leftMargin + borderWidth,
      y: bodyWidth + sliderMargin,
      w: bodyWidth - borderWidth * 2,
      h: sliderHeight - borderWidth * 2,
      r: sliderHeight / 2 - borderWidth,
      marker: marker,
      border: borderStyles
    })*/]; // Create an iroStyleSheet for this colorWheel's CSS overrides

    this.stylesheet = new stylesheet(); // Create an iroColor to store this colorWheel's selected color

    this.color = new color(); // Whenever the selected color changes, trigger a colorWheel update too

    this.color._onChange = this._update.bind(this);
    this.color.set(opts.color || opts.defaultValue || "#fff"); // Hacky workaround for a couple of Safari SVG url bugs
    // See https://github.com/jaames/iro.js/issues/18
    // TODO: perhaps make this a seperate plugin, it's hacky and takes up more space than I'm happy with

    this.on("history:stateChange", function (base) {
      this$1.svg.updateUrls(base);
    }); // Listen to events

    listen(this.svg.el, [EVENT_MOUSEDOWN, EVENT_TOUCHSTART], this, {
      passive: false
    });
    this.emit("mount", this);
  };
  /**
    * @desc update the selected color
    * @param {Object} color - an iroColor object with the new color value
    * @param {Object} changes - booleans for each HSV channel: true if the new value is different to the old value, else false
    * @access protected
  */


  colorPicker.prototype._update = function _update (color$$1, changes) {//console.log('colorpicker.prototype');
      var this$1 = this;

    var rgb = color$$1.rgbString;
    var css = this.css; // Loop through each UI element and update it

    for (var i = 0; i < this.ui.length; i++) {
      this$1.ui[i].update(color$$1, changes);
    } // Update the stylesheet too


    for (var selector in css) {
      var properties = css[selector];

      for (var prop in properties) {
        this$1.stylesheet.setRule(selector, prop, rgb);
      }
    } // Prevent infinite loops if the color is set inside a `color:change` callback


    if (!this._colorChangeActive) {
      // While _colorChangeActive = true, this event cannot be fired
      this._colorChangeActive = true;
      this.emit("color:change", color$$1, changes);
      this._colorChangeActive = false;
    }
  };
  /**
    * @desc Set a callback function for an event
    * @param {String} eventType Name of the event to listen to, pass "*" to listen to all events
    * @param {Function} callback Event callback
  */


  colorPicker.prototype.on = function on (eventType, callback) {//console.log('function in colorpicker.protoype.on');
    var events = this._events;
    (events[eventType] || (events[eventType] = [])).push(callback);
  };
  /**
    * @desc Remove a callback function for an event added with on()
    * @param {String} eventType The name of the event
    * @param {Function} callback The watch callback to remove from the event
  */


  colorPicker.prototype.off = function off (eventType, callback) {console.log('colorPicker.prototype.off');
    var eventList = this._events[eventType];
    if (eventList) { eventList.splice(eventList.indexOf(callback), 1); }
  };
  /**
    * @desc Emit an event
    * @param {String} eventType The name of the event to emit
    * @param {Array} args array of args to pass to callbacks
  */


  colorPicker.prototype.emit = function emit (eventType) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    var events = this._events,
        callbackList = (events[eventType] || []).concat(events["*"] || []);

    for (var i = 0; i < callbackList.length; i++) {
      callbackList[i].apply(null, args);
    }
  };
  /**
    * @desc DOM event handler
    * @param {Event} e DOM event (currently either mouse or touch events)
  */


  colorPicker.prototype.handleEvent = function handleEvent (e) {//console.log('handle');
      var this$1 = this;

    // Detect if the event is a touch event by checking if it has the `touches` property
    // If it is a touch event, use the first touch input
    var point = e.touches ? e.changedTouches[0] : e,
        // Get the screen position of the UI
    rect = this.svg.el.getBoundingClientRect(),
        // Convert the screen-space pointer position to local-space
    x = point.clientX - rect.left,
        y = point.clientY - rect.top;

    switch (e.type) {
      case EVENT_MOUSEDOWN:
      case EVENT_TOUCHSTART:console.log('mousedown event');
        // Loop through each UI element and check if the point "hits" it
        for (var i = 0; i < this.ui.length; i++) {
          var uiElement = this$1.ui[i]; // If the element is hit, this means the user has clicked the element and is trying to interact with it

          if (uiElement.checkHit(x, y)) {
            // Set an internal reference to the uiElement being interacted with, for other internal event handlers
            this$1._mouseTarget = uiElement; // Attach event listeners

            listen(document, [EVENT_MOUSEMOVE, EVENT_TOUCHMOVE, EVENT_MOUSEUP, EVENT_TOUCHEND], this$1, {
              passive: false
            }); 
// Emit input start event
            this$1.emit("input:start", this$1.color);
// Finally, use the position to update the picked color
            this$1.color.hsv = this$1._mouseTarget.input(x, y);
// Simulate a keyup on the input jscolor element so the color change is immediately updated 
            var input = document.getElementById('jscolor');
            input.focus();
            var ev = document.createEvent('Event');
            ev.initEvent('keyup');
            input.dispatchEvent(ev);
          }
        }

        break;

      case EVENT_MOUSEMOVE:
      case EVENT_TOUCHMOVE:
        // Use the position to update the picker color
        this.color.hsv = this._mouseTarget.input(x, y);
        break;

      case EVENT_MOUSEUP:
      case EVENT_TOUCHEND:
        this._mouseTarget = false;console.log('about to emit');
        this.emit("input:end", this.color);
        unlisten(document, [EVENT_MOUSEMOVE, EVENT_TOUCHMOVE, EVENT_MOUSEUP, EVENT_TOUCHEND], this);
        break;
    }

    if (this._mouseTarget) {
      e.preventDefault();
    }
  };

  var iro = {
    Color: color,
    ColorPicker: colorPicker,
    Stylesheet: stylesheet,
    version: "3.5.3"
  };

  return iro;

})));

function SetColors(r,g,b,a) {
	ra=PutInRange(Math.round(r+(255-r)*grade1),0,255);
	ga=PutInRange(Math.round(g+(255-g)*grade1),0,255);
	ba=PutInRange(Math.round(b+(255-b)*grade1),0,255);

	rb=PutInRange(Math.round(r+(255-r)*grade2),0,255);
	gb=PutInRange(Math.round(g+(255-g)*grade2),0,255);
	bb=PutInRange(Math.round(b+(255-b)*grade2),0,255);

	rc=PutInRange(Math.round(r*grade3),0,255);
	gc=PutInRange(Math.round(g*grade3),0,255);
	bc=PutInRange(Math.round(b*grade3),0,255);

	rd=PutInRange(Math.round(r*grade4),0,255);
	gd=PutInRange(Math.round(g*grade4),0,255);
	bd=PutInRange(Math.round(b*grade4),0,255);

	colora="("+ra+","+ga+","+ba+")";
	colorb="("+rb+","+gb+","+bb+")";
	colorc="("+r+","+g+","+b+")";
	colord="("+rc+","+gc+","+bc+")";
	colore="("+rd+","+gd+","+bd+")";

	for (i=0;i<a.length;i+=2) {
		document.getElementById(a[i]+'c'+a[i+1]+'a').style.backgroundColor='rgb'+colora;
		document.getElementById(a[i]+'c'+a[i+1]+'b').style.backgroundColor='rgb'+colorb;
		document.getElementById(a[i]+'c'+a[i+1]+'c').style.backgroundColor='rgb'+colorc;
		document.getElementById(a[i]+'c'+a[i+1]+'d').style.backgroundColor='rgb'+colord;
		document.getElementById(a[i]+'c'+a[i+1]+'e').style.backgroundColor='rgb'+colore;
		
		document.getElementById(a[i]+'c'+a[i+1]+'a').innerHTML='#'+RGB2Hex(ra,ga,ba)+'<br>'+colora;
		document.getElementById(a[i]+'c'+a[i+1]+'b').innerHTML='#'+RGB2Hex(rb,gb,bb)+'<br>'+colorb;
		document.getElementById(a[i]+'c'+a[i+1]+'c').innerHTML='#'+RGB2Hex(r,g,b)+'<br>'+colorc;
		document.getElementById(a[i]+'c'+a[i+1]+'d').innerHTML='#'+RGB2Hex(rc,gc,bc)+'<br>'+colord;
		document.getElementById(a[i]+'c'+a[i+1]+'e').innerHTML='#'+RGB2Hex(rd,gd,bd)+'<br>'+colore;
	}
}

function HueShift(h,s) {
	h+=s;
	while (h>=360.0) h-=360.0;
	while (h<0.0) h+=360.0;
	return h;
}

function PutInRange(n,l,h) { return (n<l)?l:((n>h)?h:n); }

function SetHex(objid,val,i) {
	var ob;
	var thisval=Dec2Hex(val);
	window['save'+objid]=thisval;
	document.getElementById(objid).value=thisval;
	if (i) {
		ob=document.getElementById('jscolor');
		ob.value=
			((i==1)?thisval:ob.value.substr(0,2))
			+((i==2)?thisval:ob.value.substr(2,2))
			+((i==3)?thisval:ob.value.substr(4,2));
	}
}

function SetDec(objid,val,i) {
	var ob,j;
	var thisval=Hex2Dec(val);
	window['save'+objid]=thisval+' ';
	document.getElementById(objid).value=thisval;
	if (val.length>2) val=substr(val,0,2);
	else for (j=val.length;j<2;j++) val+='0';
	if (i) {
		ob=document.getElementById('jscolor');
		ob.value=
			((i==1)?val:ob.value.substr(0,2))
			+((i==2)?val:ob.value.substr(2,2))
			+((i==3)?val:ob.value.substr(4,2));
	}
}

function DoKeyUp(el) {
	var i,initing;
	if (!(initing=(typeof(el)==='undefined'))) {
		thisid=el.id;
		thisval=el.value;
	}
	if (initing||(thisval!=window['save'+thisid])) {
		if (!initing) {
			if (thisid=='ri') SetHex('rih',thisval,1);
			else if (thisid=='gi') SetHex('gih',thisval,2);
			else if (thisid=='bi') SetHex('bih',thisval,3);
			else if (thisid=='rih') SetDec('ri',thisval,1);
			else if (thisid=='gih') SetDec('gi',thisval,2);
			else if (thisid=='bih') SetDec('bi',thisval,3);
			else if (thisid=='jscolor') {
				for (i=thisval.length;i<6;i++) thisval+='0';
				SetDec('ri',thisval.substr(0,2),0);
				SetDec('gi',thisval.substr(2,2),0);
				SetDec('bi',thisval.substr(4,2),0);
				SetHex('rih',Hex2Dec(thisval.substr(0,2)),0);
				SetHex('gih',Hex2Dec(thisval.substr(2,2)),0);
				SetHex('bih',Hex2Dec(thisval.substr(4,2)),0);
			}
			window['save'+thisid]=thisval;
		}
		if (initing||(saveri.length && savegi.length && savebi.length && saveangle.length &&
			savegrade1.length && savegrade2.length && savegrade3.length && savegrade4.length)
		) {
			running=running?2:1;
			while (running) {
				r=parseInt(saveri);
				g=parseInt(savegi);
				b=parseInt(savebi);
				angle=parseFloat(saveangle);
				grade1=PutInRange(parseFloat(savegrade1),-2.0,1.0);
				grade2=PutInRange(parseFloat(savegrade2),-2.0,1.0);
				grade3=PutInRange(parseFloat(savegrade3),0,2.0);
				grade4=PutInRange(parseFloat(savegrade4),0,2.0);
				if (running==2) { running=1; continue; }
				
				// core color
				SetColors(r,g,b,Array('m','1','c','1','a','2','s','2','t','1'));
				if (running==2) { running=1; continue; }
				
				// triadic
				SetColors(g,b,r,Array('t','2'));
				if (running==2) { running=1; continue; }
				
				SetColors(b,r,g,Array('t','3'));
				if (running==2) { running=1; continue; }
				
				thisrgb=new Object();
				thisrgb.r=r;
				thisrgb.g=g;
				thisrgb.b=b;
				
				// complement
				temprgb=thisrgb;
				temphsv=RGB2HSV(temprgb);
				temphsv.hue=HueShift(temphsv.hue,180.0);
				temprgb=HSV2RGB(temphsv);
				SetColors(temprgb.r,temprgb.g,temprgb.b,Array('c','2'));
				if (running==2) { running=1; continue; }
				
				// analogous
				temprgb=thisrgb;
				temphsv=RGB2HSV(temprgb);
				temphsv.hue=HueShift(temphsv.hue,angle);
				temprgb=HSV2RGB(temphsv);
				SetColors(temprgb.r,temprgb.g,temprgb.b,Array('a','1'));
				if (running==2) { running=1; continue; }
				
				temprgb=thisrgb;
				temphsv=RGB2HSV(temprgb);
				temphsv.hue=HueShift(temphsv.hue,0.0-angle);
				temprgb=HSV2RGB(temphsv);
				SetColors(temprgb.r,temprgb.g,temprgb.b,Array('a','3'));
				if (running==2) { running=1; continue; }
				
				// split complementary
				temprgb=thisrgb;
				temphsv=RGB2HSV(temprgb);
				temphsv.hue=HueShift(temphsv.hue,180.0-angle);
				temprgb=HSV2RGB(temphsv);
				SetColors(temprgb.r,temprgb.g,temprgb.b,Array('s','1'));
				if (running==2) { running=1; continue; }
				
				temprgb=thisrgb;
				temphsv=RGB2HSV(temprgb);
				temphsv.hue=HueShift(temphsv.hue,180.0+angle);
				temprgb=HSV2RGB(temphsv);
				SetColors(temprgb.r,temprgb.g,temprgb.b,Array('s','3'));
				if (running==2) { running=1; continue; }
				
				running=0;
			}
		}
	}
}

hexdig='0123456789ABCDEF';
function Dec2Hex(d) {
	return hexdig.charAt((d-(d%16))/16)+hexdig.charAt(d%16);
}
function Hex2Dec(h) {
	h=h.toUpperCase();
	d=0;
	for (i=0;i<h.length;i++) {
		d=d*16;
		d+=hexdig.indexOf(h.charAt(i));
	}
	return d;
}

function RGB2Hex(r,g,b) {
	return Dec2Hex(r)+Dec2Hex(g)+Dec2Hex(b);
}

// RGB2HSV and HSV2RGB are based on Color Match Remix [http://color.twysted.net/]
// which is based on or copied from ColorMatch 5K [http://colormatch.dk/]
function HSV2RGB(hsv) {
	var rgb=new Object();
	if (hsv.saturation==0) {
		rgb.r=rgb.g=rgb.b=Math.round(hsv.value*2.55);
	} else {
		hsv.hue/=60;
		hsv.saturation/=100;
		hsv.value/=100;
		i=Math.floor(hsv.hue);
		f=hsv.hue-i;
		p=hsv.value*(1-hsv.saturation);
		q=hsv.value*(1-hsv.saturation*f);
		t=hsv.value*(1-hsv.saturation*(1-f));
		switch(i) {
		case 0: rgb.r=hsv.value; rgb.g=t; rgb.b=p; break;
		case 1: rgb.r=q; rgb.g=hsv.value; rgb.b=p; break;
		case 2: rgb.r=p; rgb.g=hsv.value; rgb.b=t; break;
		case 3: rgb.r=p; rgb.g=q; rgb.b=hsv.value; break;
		case 4: rgb.r=t; rgb.g=p; rgb.b=hsv.value; break;
		default: rgb.r=hsv.value; rgb.g=p; rgb.b=q;
		}
		rgb.r=Math.round(rgb.r*255);
		rgb.g=Math.round(rgb.g*255);
		rgb.b=Math.round(rgb.b*255);
	}
	return rgb;
}

function min3(a,b,c) { return (a<b)?((a<c)?a:c):((b<c)?b:c); }
function max3(a,b,c) { return (a>b)?((a>c)?a:c):((b>c)?b:c); }

function RGB2HSV(rgb) {
	hsv = new Object();
	max=max3(rgb.r,rgb.g,rgb.b);
	dif=max-min3(rgb.r,rgb.g,rgb.b);
	hsv.saturation=(max==0.0)?0:(100*dif/max);
	if (hsv.saturation==0) hsv.hue=0;
 	else if (rgb.r==max) hsv.hue=60.0*(rgb.g-rgb.b)/dif;
	else if (rgb.g==max) hsv.hue=120.0+60.0*(rgb.b-rgb.r)/dif;
	else if (rgb.b==max) hsv.hue=240.0+60.0*(rgb.r-rgb.g)/dif;
	if (hsv.hue<0.0) hsv.hue+=360.0;
	hsv.value=Math.round(max*100/255);
	hsv.hue=Math.round(hsv.hue);
	hsv.saturation=Math.round(hsv.saturation);
	return hsv;
}

/*
saveri="0";
savegi="0";
savebi="0";
saverih="00";
savegih="00";
savebih="00";
savehex="000000";
saveangle="30.0";
savegrade1="0.8";
savegrade2="0.4";
savegrade3="0.6";
savegrade4="0.3";
*/
running=0;

function ColorWheelInit() {
	saveri=document.getElementById('ri').value;
	savegi=document.getElementById('gi').value;
	savebi=document.getElementById('bi').value;
	saverih=document.getElementById('rih').value;
	savegih=document.getElementById('gih').value;
	savebih=document.getElementById('bih').value;
	savehex=document.getElementById('jscolor').value;
	saveangle=document.getElementById('angle').value;
	savegrade1=document.getElementById('grade1').value;
	savegrade2=document.getElementById('grade2').value;
	savegrade3=document.getElementById('grade3').value;
	savegrade4=document.getElementById('grade4').value;
	document.getElementById('ri').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('gi').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('bi').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('rih').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('gih').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('bih').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('jscolor').onkeyup=function() { console.log('got keyup on jscolor');DoKeyUp(this); }
	document.getElementById('angle').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('grade1').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('grade2').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('grade3').onkeyup=function() { DoKeyUp(this); }
	document.getElementById('grade4').onkeyup=function() { DoKeyUp(this); }
	DoKeyUp();
}

window.onload=function() { ColorWheelInit(); }

var colorPicker = new iro.ColorPicker(".colorPicker", {
  // color picker options
  // Option guide: https://iro.js.org/guide.html#Color-Picker-Options
  width: 250,
  height: 250,
  color: {r: 255, g: 0, b: 0},
  anticlockwise: true,
  borderWidth: 1,
  borderColor: "#fff",
  // Dynamic CSS guide: https://iro.js.org/guide.html#Dynamic-CSS
});
var values = document.getElementById("jscolor");
var values1 = document.getElementById("ri");
var values2 = document.getElementById("gi");
var values3 = document.getElementById("bi");


// https://iro.js.org/guide.html#color-change
colorPicker.on("color:change", function(color){  //console.log('colorPicker.on');// Show the current color in different formats
  // Using the selected color: https://iro.js.org/guide.html#Using-the-Selected-Color
 // hexString = hexString.replace('#', '');
 values.value = [color.hexString.replace('#', '')];
  values1.value = [color.hexString.substr(1,2)];
  values2.value = [color.hexString.substr(3,2)];
  values3.value = [color.hexString.substr(5,2)];
  // Get the dynamic stylesheet content and pretty-print it by replacing newlines and tabs with suitable html
  
})


</script>
          <div class="container" style="max-width: 80%;">
          <div class="form-group">
            <label>Pilih Color Wheel</label>
            <select class="form-control" onchange="location = this.value;">
                <option value="https://color.loxa.tech/index.php?color=table">Table Color Harmony</option>
                <option value="https://color.loxa.tech/index.php?color=triadic">Color Wheel Triadic</option>
                <option value="https://color.loxa.tech/index.php?color=analogous">Color Wheel Analagous</option>
                <option value="https://color.loxa.tech/index.php?color=complement">Color Wheel Complementary</option>
            </select>
          </div>
          </div>
        </div>
      </div>
      <footer class="footer">
        <p> Color Wheel 2022</p>
      </footer>
    </div>
  </div>
  <!-- /container -->
  <!-- partial -->
  <script src='https://cdn.jsdelivr.net/npm/@jaames/iro@beta/dist/iro.min.js'></script>
  <script src="js/script_triadic.js"></script>
</body>
</html>
